<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Wonjae (Dan) Kim | Exploiting Contemporary ML</title>
<meta name="description" content="Wonjae (Dan) Kim
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/Exploiting_Contemporary_ML/">

<!-- Theming-->

  <script src="/assets/js/theme.js"></script>



  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-47120899-4"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-47120899-4');
  </script>


  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

  <!-- Nav Bar -->
  <nav id="navbar"
    class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="https://wonjae.kim/">
        <span class="font-weight-bold">Wonjae</span> (Dan) Kim
      </a>
      
      <!-- Navbar Toogle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav"
        aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              About
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              Blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
            <a class="nav-link" href="/publications/">
              Publications
              
            </a>
          </li>
          
          
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/assets/pdf/cv.pdf">
              CV
            </a>
          </li>
          
          <div class="toggle-container">
            <a id="light-toggle">
              <i class="fas fa-moon"></i>
              <i class="fas fa-sun"></i>
            </a>
          </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>

  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Exploiting Contemporary ML</h1>
    <p class="post-meta">January 2, 2021</p>
  </header>

  <article class="post-content">
    <p>이 글은 제가 졸업한 <a href="http://hcil.snu.ac.kr/">HCI 연구실</a>로부터 최신 ML 모델을 HCI 연구에 <strong>응용</strong>만 하길 원한다면 뭘 배워야 하는지 알려달라는 요청이 와서 간단한 기본 지식과 응용하고 싶은 분야를 묻는 설문지를 돌린다음 반응을 보고 적은 가이드라인입니다.</p>

<h4 id="제목의-의미">제목의 의미</h4>
<ul>
  <li>Exploiting: ML 모델에 대한 <strong>원론적 이해</strong>는 비전공자로서 모델 사용을 함에 있어 건너뛰어도 상관 없다는 뜻을 담았습니다.</li>
  <li>Contemporary: 어제 아카이브에 올라온 논문도 exploit 할 수 있어야 한다는 뜻을 담았습니다.</li>
</ul>

<h3 id="학교-강의의-한계">학교 강의의 한계</h3>
<p>학교 수업에서 커버할 수 있는 지식은 어느 선까지로 정의해야 할까요? 어떤 학문이 가지를 쳐서 하나의 나무를 이룬다고 생각했을 때, 모든 가지가 공유하는 밑동에 해당하는 지식을 커버해야하는 것이 옳을 겁니다. 머신러닝이라는 학문에서 모든 가지가 공유하는 밑동은 뭘까요? 대부분의 학교 강의자는 이게 실해석학과 그 응용인 확률론이라는 것에 동의할 겁니다. 물론 맞는 말이지만, 너무 밑동입니다 (머신러닝 &lt; 통계학 &lt; 확률론 &lt; 실해석학 &lt; 해석학 &lt; 수학). 반대로 머신러닝의 가지인 세부 분야를 관찰해봅시다. 예컨대 수많은 음악 데이터를 기반으로 새로운 음악을 만들어내고 (더 정확하게는 샘플링하고) 싶다고 합시다. 중요한 부분만 짚으면 해당 분야의 위계는 아마 이럴 겁니다: 음악 생성 &lt; 소리 생성 &lt; 시계열 생성 &lt; 시퀀스 생성 &lt; 생성 모델 &lt; 머신러닝. 더 응용성이 높은 가지일수록 더 밑동의 지식과는 멀어지게 됩니다. 그 밑동의 지식을 전부 알아야 할 필요도 없어지게 됩니다.</p>

<p>예를 들어 왜 시퀀스 생성 &lt; 생성 모델이냐 하면, 생성 모델의 종류로 많이 사용되는 방법만 보더라도 non-tractable distribution을 사용하는 방법, tractable 한 variational distribution을 사용하는 방법, 또 그 distribution의 값을 어떻게 data와 맵핑하는지에서 invertible한 방법 (volume-preserving), density를 보존하지 않는 방법 등 다양한 접근 방법이 있고 이들 중 <strong>시퀀셜 데이터</strong>에 잘 들어맞는 방법들이 따로 있고 <strong>논시퀀셜 데이터</strong>에 잘 들어맞는 방법들이 따로 있습니다. 물론 어떤 방법이 어떤 세부 태스크에 맞는지는 많은 empirical study가 이루어졌기 때문에 알 수 있는 부분이고요. 시퀀스 생성에서 현재 대세를 이루고 있는 생성 모델이 <em>volume-preserving mapping from diagonal gaussian distribution</em> (e.g., normalizing flows)이라고 가정해봅시다. 그럼 사실 음악 생성, 소리 생성, 시계열 생성을 응용하고자 하는 사람은 normalizing flows만 알면 됩니다. 만약 그 대세를 거슬러서 (예를 들었을 뿐이지 둘 다 대세입니다. 진짜 대세가 아닌 비주류는 오디오 처리를 주력으로 하지 않는 제가 몰라서 못적기 때문에 이렇게 두개를 적어놓은겁니다.) 다른 타입의 생성 모델로도, 예컨대 <em>free-form mapping from gaussian distribution; learning mapping via adversarial loss</em> (e.g., GANs)으로 normalizing flows의 성능을 이기고자 한다면 그 외 다른 생성 모델에 대해서도 잘 알아야겠지만 <strong>현재 SoTA를 응용만 하고자 하는 사람</strong>은 다시 말하지만 굳이 알 필요가 없습니다.</p>

<p>하물며 생성 모델 또한 수 많은 머신러닝 모델 방법론중 (대세긴 하지만) 하나일 뿐인데, 우리가 <strong>머신러닝</strong>이라는 이름의 강의 전체를 듣는다 한들 얼마나 응용하고자 하는 부분이랑 겹치는 내용을 얻어갈 수 있을까요? 바로 어제 나온 SoTA 모델을 읽는다고 했을 때, 학교 강의에서 배운 걸 그대로 사용하는 부분은 거의 없을겁니다. 제가 말한 <strong>머신러닝</strong>이라는 이름의 강의의 대표격으로 <a href="https://www.coursera.org/learn/machine-learning">Andrew Ng의 강의</a>나 <a href="https://www.amazon.com/Machine-Learning-Probabilistic-Perspective-Computation/dp/0262018020">Murphy의 책</a>을 예로 들고 싶습니다. 이러한 명강의나 명저를 수십시간을 들여서 학습한다고 해도, 어제 나온 SoTA 논문을 읽고 구현할 수 없을 겁니다. 위에서 말했듯 이런 강의는 대세를 넘어서 새로운 아이디어로 새 논문을 쓸 연구자의 <strong>기초</strong> 코스로 훌륭할 뿐입니다. 머신러닝 연구를 위해서는 위와 같은 기초 (또 그걸 넘어서 실해석학과 미분기하학에 이르는)를 쌓고 연구하고자 하는 좁은 범위를 구성하는 어제까지 나온 굵직한 연구들의 literature를 알아야 합니다.</p>

<p>그럼 우리는 EXPLOIT을 할거니까 저런 강의 말고 뭘 들어야 할 것인가? 4년 전까지는 <a href="http://cs231n.stanford.edu/">CS231n</a> 정도면 최신 연구를 읽고 구현하는데에 (즉, exploit 하는데에) 무리가 없었습니다. 물론 그 당시에도 CS231n만 들어서는; 다시 말하지만 새로운 방법론을 제시할만한 지식을 쌓기는 어려웠습니다. 그랬었기 때문에 CS231n을 롤모델로 많은 대학의 대학원 머신러닝 응용 강의나 학부 고학년 머신러닝 응용 강의가 개설되었고 지금도 유지되고 있습니다. 그런데 아쉽게도 CS231n이 최초 개설된 Winter 2015 이후로 머신러닝에는 2012~2015보다 더 큰 발전이 있었고 이는 들어가는 연구 인력과 자원의 양이 기하급수적으로 커졌으니 당연합니다. 이제는 이 강의만으로는 CS231n이 주력으로 삼는 컴퓨터 비전 영역이라도 어제 나온 논문을 읽고 구현하기 어렵게 되었습니다. 이게 적어도 앞으로 최근 연구를 반영한 강의가 나오기 전까지는 학교 강의가 가지는 한계입니다.</p>

<h3 id="2016년-이후의-세계의-변화점">2016년 이후의 세계의 변화점<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup></h3>
<p>2016년 DeepMind의 AlphaGo Lee이후 구글은 본격적으로 머신러닝 기업으로의 전환을 모색했습니다. 머신러닝 기업이 가질 수 있는 배타성이 뭐가 있을까요? 현재 머신러닝 학계는 논문의 재현성에 엄청난 피어프레셔를 줍니다. 즉 논문을 사용하는데 들어간 데이터와 소스코드의 완전한 공개를 요구한다는 것이죠. 그럼 “이 분야에서 1등을 해봤자 우리 기업의 우수한 모델을 세계에 공유하게 되는데 어떡하지?” 라는 생각을 할 수밖에 없었을 겁니다. 가장 단순한 아이디어는 <strong>학술용 데이터셋</strong>과 별개로 <strong>사내 데이터셋</strong>을 구축하는 것입니다. 누구나 생각할 수 있고, 이미 <em>데이터 자본(주의)</em>라는 키워드로 많은 사람들이 알고있는 방법입니다. 실제로 구글과 페이스북은 각자 가지고있는 거대 데이터 파이프라인을 통해 JFT-300M이나 Instagram-1B 같은 비공개 데이터셋을 구축했습니다. 물론 학계에 논문을 낼때는 ImageNet 같은 (작은) 학술 데이터셋에 대한 리포트를 필수적 주요하게 첨부합니다.</p>

<p>그럼 이 <em>데이터 자본</em>을 가지고 실제로 배타적인 강력한 모델을 만들어야 하는데요. 이 지점에서 기업들을 커다란 장애물을 하나 치워야 함을 느낍니다. 바로 convolution과 recurrence입니다. 혹시 이 두 구조가 딥러닝을 받드는 축이라고 생각하시나요? 아쉽게도 이제는 아닙니다. 두 구조는 (소규모 자본을 가진 입장에서는) 좋은 특징인 data efficient하다는 특징을 가지는데요. 말 그대로 적은 데이터에서도 overfitting이 다른 모델보다 적다는 뜻입니다. 이러한 특징은 데이터의 성질에 적당히 들어맞는 사람의 inductive bias를 모델에 주입해주면 갖춰집니다. 예로, convolution은 “어떤 값의 spatially close한 값들은 연관된 값이다” 라던지 말이죠; 실제로 이미지 데이터의 성질과 어느정도 일치하죠? <sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup></p>

<p>논문 <a href="https://arxiv.org/abs/1806.01261">Relational inductive biases, deep learning, and graph networks</a>에서 이러한 (relational) inductive bias (IB)의 분류를 정리합니다.
그리고 예시로 FC, Convolutional, Recurrent, Graph 4가지의 자주 사용되는 NN layer가 어떠한 IB를 가지는지 제시하는데요.
인풋으로 받는 데이터의 형태를 flatten해서 (L (length), C (channel))라고 할 때, 위 논문에서 다루는 relative IB는 L개의 C-dim vector 간의 relation에 어떠한 bias를 주입하는지에 대한 겁니다.
앞서 말했듯 convolution의 경우 spatially close = local한 vector간에 bidirection link를 조성하고, recurrent의 경우 local한 vector간의 unidirection link를 조성합니다.
FC의 경우에는 어떠한 링크도 조성하지 않으므로 IB가 없다고 해석합니다.
Graph의 경우 모든 vector간에 bidirection link를 조성하므로 가장 높은 IB가 가해져있다고 볼 수 있습니다.</p>

<p>해당 논문에서는 <a href="https://psycnet.apa.org/record/1994-98068-004">The interaction of nature and nurture in development: A parallel distributed processing perspective</a>를 인용하여 높은 IB가 overfit을 방지한다고 말합니다.
하지만 반대로 생각하면 IB를 적게 주입하면 overfit이 될 가능성이 높은, 빠르게 수렴하는 모델을 확보할 수 있습니다.
Convolution과 recurrence 구조는 이런 trade-off에서 적절한 IB 주입의 균형점을 찾았고 data efficient하다는 특징을 가질 수 있었습니다.
FC와 graph 사이에는 convolution과 recurrent 말고도 사람이 직접 디자인한 도메인에 아주 잘 맞는 IB도 존재할 수 있습니다.
실제로 수 년간 이러한 “모델의 구조에 IB를 녹여볼까” 하는 연구는 딥러닝 연구의 주축이 되어왔습니다.</p>

<p>하지만 엄청난 양의 데이터를 가진 기업은 최고 수준의 regularization을 필요로 하고, 결국 모든 vector들이 전부 연결된 임의 연결성 IB를 주입한 모델을 택할 수 밖에 없습니다.
그 결과 나온 모델이 2017년 NIPS에서 발표한 <a href="https://arxiv.org/abs/1706.03762">Attention Is All You Need</a>의 Transformer입니다.
Transformer와 Graph NN은 <a href="https://graphdeeplearning.github.io/post/transformers-are-gnns/">동치 관계</a>이고, 모든 vector들 간의 연결이 IB로 주입되어있습니다.</p>

<p>높은 IB를 가진 모델을 fit 시키려면 많은 양의 데이터가 필요합니다. 즉, data efficient하지 않습니다. 실제로 “Attention is All You Need”에서도 데이터의 양이 적은 경우 기존의 recurrent 방법론과 대등하거나 안좋은 성능을 보입니다. 대중들이 논문의 수치적 결과만 보고 ‘attention is all you need 라더니 성능은 그냥 RNN하고 별 차이 없네’ 라고 생각하던 2018년 전반기, Allen AI에서 2018년 2월에 <a href="https://arxiv.org/abs/1802.05365">Deep contextualized word representations</a> (ELMo) 라는 논문을 <strong>LSTM</strong> 구조 기반으로 내놓습니다. ELMo는 pretrain-finetune 파이프라인을 성공적으로 학계에 제시했고, 연이어서 2018년 4월 <a href="https://arxiv.org/abs/1804.07461">GLUE: A Multi-Task Benchmark and Analysis Platform for Natural Language Understanding</a>, GLUE 벤치마크가 공개됩니다. 이 논문에서 baseline으로 사용된 ELMo는 또 뛰어난 성능을 보였고, pretrain-finetune 파이프라인의 성능을 다시 입증합니다.</p>

<p>Pretrain-finetune 파이프라인은 pretrain 과정에서 각 downstream task들보다 훨씬 많은 데이터를 소모하는 것이 필수였고, 이는 data efficient한 LSTM에게는 별로 맞지 않는 일이었습니다. 얼마 지나지 않아 2018년 10월에 그 유명한 <a href="https://arxiv.org/abs/1810.04805">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a>, BERT가 공개되었고 대중들도 이제는 진짜 “attention is all you need”임을 알게되죠. 단, “if you have data to fit them all”의 조건은 숨겨진 채로요. 데이터 자본, 컴퓨팅 자본의 맛을 본 기업들은 그 이후로 data efficient 모델에 대한 연구를 적극적으로 행하고 있지 않습니다. 엄청난 양의 데이터와 큰 트랜스포머로 pretrain한 모델을 적은 양의 다운스트림에 finetune하고는 data efficient하다고 말하는 기만적인 연구는 빼고요. 이게 2015년 겨울 CS231n이 나온 뒤로 벌어진 일들입니다.</p>

<h3 id="성역-없는-침범">성역 없는 침범</h3>
<p>BERT 이후 2019년은 NLP에 있어서 숙청의 해였습니다. 모든 방법론들이 몰살당하고 pretrained transformer가 그 자리를 차지했죠. 아주 정교한 언어학적 parse tree를 structural bias로 준 모델 조차 많은 데이터로 프리트레인 된 transformer 앞에서는 그냥 초라한 퍼포먼스밖에 낼 수 없었습니다. NLP가 정리되고, 2019년 말~2020년 초에 image에서도 Language Modeling과 같이 데이터만 주어지면 그 데이터로부터 스트럭쳐를 뽑아내어 슈퍼비전으로 사용하는 <em>Self-supervised Learning</em>을 적용하기 위한 연구가 활발히 이루어집니다. 2019년 11월 <a href="https://arxiv.org/abs/1911.05722">Momentum Contrast for Unsupervised Visual Representation Learning</a> (MoCo), 2020년 2월 <a href="https://arxiv.org/abs/2002.05709">A Simple Framework for Contrastive Learning of Visual Representations</a> (SimCLR) 등이 대표적이고 이 모델들은 ELMo가 제시한 pretrain-finetune 방법을 이미지에도 적용함을 목표로 합니다. 예를 들어서 MoCo의 경우 10억장의 페이스북 독점 데이터셋인 Instagram-1B을 레이블 없이 이미지만 사용하고 그 CNN weight를 그대로 R-CNN에 백본으로 사용하면 이미지넷을 레이블과 함께 학습한 CNN보다 Object Detection 등의 다운스트림 태스크에서 더 높은 퍼포먼스를 낼 수 있음을 보입니다.</p>

<p>그럼 구조상으로도 convolution이 설 자리를 없애는게 대규모의 데이터를 가진 기업 입장에서는 당연한 수순일 겁니다. 2020년 5월 <a href="https://arxiv.org/abs/2005.12872">End-to-End Object Detection with Transformers</a>, DETR에서는 detection과 segmentation에서 R-CNN 구조보다 더 좋은 성능을 transformer가 낼 수 있음을 보이고, 2020년 10월 <a href="https://arxiv.org/abs/2010.11929">An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale</a>, ViT에서는 드디어 pixel에서 feature에 이르는 CNN이 독점해왔던 인코더를 transformer가 대체하고 더 좋은 성능을 낼 수 있음을 보입니다. 2021년 1월 현재, 아직까지 이미지에는 GLUE와 같은 “대표적인” 벤치마크 셋이 없습니다. 하지만 곧 ViT 구조로 아주 큰 데이터셋에서 pretrain을 수행하고 (self-supervised 방식으로) 여기에 BERT처럼 헤드를 붙여서 (detection, segmentation 등) 모든 task를 압도하는 모델과, 그걸 수치적으로 보여줄 벤치마크 셋이 곧 나올 것은 불을 보듯 뻔한 일입니다.</p>

<h3 id="exploit을-하기-위해서-배워야-할-것">Exploit을 하기 위해서 배워야 할 것</h3>
<p>기업들이 아직도 데이터는 공개 안해도 그 <em>pretrained weight</em>는 공개해준다는 것은 아주 다행인 일입니다. 하지만 그 와중에도 그중에서 제일 좋고 큰 모델의 weight는 공개 안하는게 어느덧 일반적이 되어가고 있습니다. 물론 그 weight는 일반적인 가속기로는 돌리기 꽤 버겁지만요. 그리고 앞서 말했듯 지금의 SoTA 모델은 복잡하고 정교한 인간의 inductive bias가 녹여진 모델이 아니라 그냥 <strong>큰 트랜스포머</strong>를 해당 태스크에 맞게 finetune한 것입니다. 설령 지금 당장 목표로 하는 응용분야에서 개별 모델이 득세하고 있다고 한들, 제 생각으로는 2023년 이내에 트랜스포머로 대체될 가능성이 농후합니다.</p>

<p>이를 모델의 다양성이 없어진다고 볼 수도 있지만, 사실 자주 인용되는 밋첼의 머신러닝 학습의 정의 ‘프로그램이 태스크 T에 대해서 경험 E를 사용해서 계량값 P로 계량한 성능을 올리는 것을 학습이라고 한다’에서 보듯 학습이라는 측면에서 모델의 구조는 그냥 부차적인 요소일 뿐이고, 어떠한 경우에도 그에 맞춰줄 수 있게 capacity만 넉넉하면 상관이 없습니다. 즉 중요한 건 태스크 T, 경험 (데이터) E, 계량값 (메트릭) P의 개선과 더 유효한 정의지, 모델은 그냥 transformer로 충분하다는 얘기입니다.</p>

<p>그럼 우리가 알아야할것은 아래의 다섯 가지로 추려볼 수 있습니다.</p>

<ol>
  <li>연산 가속기를 다루는 방법</li>
  <li>CS231n과 같은 강의: 위에서 대략적으로 짚은 2016~2020의 역사 이전이지만, 또 Andrew Ng이나 Murphy의 강의에서 다루는 것들보다는 이후인 내용에 대한 이해가 필요합니다.</li>
  <li>위에서 제가 짚어둔 논문들과 그들이 논문에서 언급하는 background</li>
  <li>내가 응용을 원하는 분야의 task 이름과 그 task를 학습하기 위한 objective function의 구조, 그리고 대표적인 academic dataset과 평가 metric</li>
  <li>빅테크 기업들이 내가 응용하고자 하는 분야에 transformer를 적용했는가? 그렇다면 그 모델의 weight는 공개되어있는가?</li>
</ol>

<p>위의 세가지는 모든 사람들이 공통적으로 학습해야 하는 부분이며, 아래 두가지는 각자의 세부 분야에 맞게 학습해야 하는 부분입니다. 1번, 연산 가속기를 다루는 방법에 대해서는 딱히 정답이 없습니다. 부딪혀가면서 익히거나 <a href="https://pytorch-lightning.readthedocs.io/en/latest/">Pytorch Lightning</a>과 같은 애드온이 engineering demands를 덜어주기를 바라는 수밖에요. 4번에 대해서는 대략적인 가이드를 아래에서 드리겠지만, <a href="https://paperswithcode.com/sota">papers with code</a>를 참조하면서 동시에 해당 분야의 survey 페이퍼를 읽고서 시작하는 것을 강력히 추천합니다. 또 5번의 경우 weight가 공개되어있지 않다면, pretraining부터 수행해야하는 문제점이 있는데, academic dataset이라도 이것을 기업이 아닌 곳에서 수행하기는 굉장히 어려우니 공개된 쪽으로 방향을 돌리기를 추천드립니다.</p>

<h4 id="nlp에서-transfer-learning에-대하여">NLP에서 Transfer Learning에 대하여</h4>
<p>앞서 말했듯이 예전에는 의미를 가지는 태스크 (예를들어 이미지넷 분류)에서 학습된 모델을 트랜스퍼하는 형태였다면, 지금은 거대한 데이터를 레이블링 없이 특정 의미 없는 태스크 (self-supervision)로 학습한 다음 트랜스퍼하는 모델들이 성능이 월등합니다. 위에 언급한 논문들에 더해서 구글의 트랜스퍼 러닝에 대한 추가적인 연구를 다룬 <a href="https://arxiv.org/abs/1910.10683">Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</a>, T5와 그 백그라운드를 읽어보시길 추천드립니다. 또한 Huggingface의 <a href="https://huggingface.co/transformers/model_doc/t5.html">pretrained weight</a>와 <a href="https://github.com/huggingface/transformers">라이브러리 코드</a>를 이해하시기를 추천드립니다.</p>

<h4 id="graph-data에-대하여">Graph data에 대하여</h4>
<p>Graph가 핫 토픽이기는 하죠, 하지만 막상 응용하기엔 그렇게 쉽지 않은 영역입니다. 우선 GNN은 transformer와 어느정도 <a href="https://graphdeeplearning.github.io/post/transformers-are-gnns/">동치 관계</a>임을 알고 가셨으면 좋겠습니다. Message passing이라던가 multi-hop등의 그래프 특정 용어 또한 트랜스포머에서 흔히 하는 연산과 별 다를바가 없죠. 만약 GNN을 응용하고자 한다면 그 커뮤니티의 용어들의 용례를 잘 알고서 내가 인코드하고자 하는 데이터가 그래프 스트럭쳐인지, 노드인지, 엣지인지 아니면 그들의 조합인지를 잘 파악해야 합니다. 이 <a href="https://arxiv.org/abs/1901.00596">서베이 논문</a>을 읽고서 시작하시기를 추천드립니다.</p>

<h4 id="xai에-대하여">XAI에 대하여</h4>
<p>XAI는 굉장히 넓은 영역을 커버합니다. 또한 통일된 의견또한 없습니다. 2017년 HCI연구실과 국보연의 산학연구에서 저와 연구실분들이 작성한 자료에서는 머신러닝 모델의 시각화 방법론을 “point-based”와 “network-based”로 나누었는데요 (Shixia Liu의 <a href="https://ieeexplore.ieee.org/abstract/document/7536654">논문</a>을 따라서), 그 이후에 시각화를 넘어서서 더 다양한 방법으로 모델을 분석할 수 있게 되었고 현재 이 모든 방법들의 통칭이 XAI입니다.</p>

<p>Interpretability vs Explainability, 두 용어의 차이에 대해서 여러가지 의견들이 있고, 통일된 의견은 없습니다. 제 의견은 Interpretability는 causality와 거의 같은 의미라고 보는 의견입니다. Interpretability란 모델 inference의 어떤 부분이 output의 cause인지를 사람이 알아낼 수 있는 정도입니다. 반면 Explainability는 모델 inference의 output에 대한 설명을 사람이나 모델 스스로 만들어내는 것을 의미합니다. Interpretability가 모델의 값들을 있는 그대로 드러내서 cause의 신뢰도를 사람이 판단하도록 한다면 explainability는 생성된 explanation으로 “내가 본 이미지가 멋져서요”라고 제시하고, 사람이 그 설명에 만족한다면 explainable하다고 볼 수 있는 것입니다. XAI가 explain의 방식으로 causal interpretation을 제시할 수도 있으므로, 두 개념은 교집합을 형성하지만 어느 한쪽이 다른 한쪽의 부분집합이 아니라고 생각합니다. 이는 제 의견입니다. 현재 학계에서는 별 의미 구분 없이 explainable and interpretable 같은 식으로 뭉뚱그려서 서술하는게 대세입니다. 다만 <a href="https://arxiv.org/abs/2006.11371">Opportunities and Challenges in Explainable Artificial Intelligence (XAI): A Survey</a>, 이 서베이 논문에서는 저와 거의 비슷한 정의를 내렸습니다.</p>

<p>저는 개인적으로 아직 시각화 기법 자체가 XAI에 딱 적용된 사례는 없는 것 같아서 아쉽습니다: 즉 instance-based XAI 기법인 Grad-CAM을 적용한다고 했을때 이 시각화를 rainbow heatmap (VIS 전공자인 우리는 딱히 좋지 않다고 알고있는) 으로 보여주는게 대세인데, 어떤 방식으로 보여줬을때 사람들이 더 causality를 잘 느끼는지에 대한 연구가 없습니다. 우리 연구실의 전공을 살려서 해보기에 좋은 주제가 아닐까요?</p>

<h4 id="할당-문제에-대하여">할당 문제에 대하여</h4>
<p>할당 문제에 대한 접근은 multi-agent reinforcement learning으로도 가능하지만, optimal transport (OT)가 훨씬 효과적이고 많이 쓰이는 방법입니다. Sinkhorn algorithm의 저자인 Marco Cuturi가 2018년에 작성한 텍스트북인 <a href="https://arxiv.org/abs/1803.00567">Computational Optimal Transport</a>의 초반 파트를 읽어보시면 아마 어떻게 활용할 수 있는지가 그려질 것 같습니다. OT의 경우 모든 연산이 미분가능하기 때문에 최근 딥러닝과 융합도 잘 되고 있으며, 할당을 원하는 피쳐가 뉴럴넷으로 구해진 경우 인코더까지 동시에 학습할 수 있을 것입니다.</p>

<h4 id="차원-축소와-뉴럴넷으로-인코드한-피쳐의-시각화적-사용법에-대하여">차원 축소와 뉴럴넷으로 인코드한 피쳐의 시각화적 사용법에 대하여</h4>
<p>차원 축소, 이름은 차원 축소이지만 여러가지 태스크를 동시에 내포하고 있습니다. 예를 들어 레즈넷으로 이미지를 분류할때 224x224x3의 이미지를 2048 벡터로 인코드 했으니 차원이 축소됐다고 말할 수도 있지만, 차원 축소를 말할때 이런식의 인코딩을 의미하지는 않죠. 그런데 2048 벡터 대신에 3차원 벡터로 인코드하면? 이미지 분류를 위한 피쳐는 semantically 가까운 이미지들끼리 서로 피쳐간 거리도 가깝게 인코드 되는 경향이 있으므로 이건 차원 축소의 의미에 부합합니다. 하지만 3차원 벡터를 feature로 사용하면 이미지 분류에 필요한 rank보다 적게 되므로 분류 태스크를 잘 학습할수가 없고 결국 feature도 의미가 없어지겠죠. 따라서 raw data를 차원축소하기 위해서는 그 데이터를 특정 피쳐로 인코드하는 인코더가 학습된 상태로 준비되어 있어야 하고 그 피쳐를 저차원으로 끌어당기는 embedding이 필요합니다.</p>

<p>응용을 위해 다음 두 가지를 생각해주셨으면 합니다.</p>
<ol>
  <li>어떤 인코더를 사용해서 데이터를 n-dimension의 피쳐로 인코드할것인가?</li>
  <li>그 피쳐를 그대로 사용할 수 있는 상황인가? 꼭 2, 3차원으로 줄여야 하는가?</li>
</ol>

<p>분류 태스크로 얻어지는 피쳐는 어느정도 가까울거라는 예측은 할 수 있지만 그 보장은 없습니다. 하지만 피쳐끼리의 거리를 보장하는 학습법이 있습니다. 바로 Deep Metric Learning (DML)이라는 방법입니다. DML은 클래스 레이블을 사용해서 인코더를 학습하지 않고 데이터간의 유사성을 사용해서 인코더를 학습합니다. 그리고 그 유사성을 우리가 슈퍼비전으로 줘야하고요. <strong>자기 자신과만 가깝다</strong>라는 식으로 슈퍼비전을 줘서 레이블 없이도 self-supervision을 형성할 수 있습니다. 다만 위에서 말했듯 이 경우 데이터가 적으면 학습이 불가능합니다.</p>

<p>DML을 통해서 얻어진 feature는 classification feature보다 훨씬 예쁘게 가까운 애들은 가깝도록, 먼 애들은 멀도록 인코드 됩니다. 사용할 encoder는 자유입니다. 흔히 이미지에 대해서 연구가 이루어지기 때문에 CNN을 쓰지만, 그래프 구조를 인코드하고 싶다면 GNN을 사용하고, 텍스트를 인코드하고 싶다면 RNN을 사용하면 됩니다; 혹은 transformer가 있는 영역이면 transformer를 사용하면 됩니다.</p>

<p>DML의 여러 논문과 구현 코드는 <a href="https://github.com/KevinMusgrave/pytorch-metric-learning">이 레포</a>를 참조하세요. 이 레포의 태스크는 대부분 visual embedding을 획득하는 것을 목표로 하지만, 언어나 다른 모달리티에서도 DML 방법은 흔히 <em>contrastive learning</em>라는 이라는 이름으로 찾아볼 수 있습니다. 예로, 문장 임베딩을 하는 논문인 <a href="https://arxiv.org/abs/1902.08564">Improving Multilingual Sentence Embedding using Bi-directional Dual Encoder with Additive Margin Softmax</a>에서는 DML에 대한 언급은 없지만, 얼굴 이미지 DML 논문인 <a href="https://arxiv.org/abs/1801.05599">Additive margin softmax for face verification</a>을 중요하게 인용하고 있습니다.</p>

<p>또 피쳐를 바로 visual mark를 사용해서 visually encode하는게 정답이 아닐 수도 있습니다. 그 데이터 포인트가 가진 여러 정보중에 더 spatially meaningful한 정보가 있다면 (e.g., GPS) spatial encoded mark는 그 정보에 양보하고 뉴럴넷으로 얻은 피쳐는 다른 층위 (detail 등)에서 사용하는 것을 고려해보는 게 어떨까요?</p>

<h4 id="시계열-데이터의-처리에-관해">시계열 데이터의 처리에 관해</h4>
<p>시계열 데이터는 시퀀스 데이터의 일부입니다. 시계열이 가지는 특징으로는 단조증가 독립변수 t의 값이 연속적이라는 특징이 있고, 데이터마다 t의 간격이 equivalent하지 않다는 특징이 있습니다. 딥러닝 era (2012~)에서 이 irregularly-sampled time series를 바로 다루는 일은 극히 최근까지 불가능하다고 여겨졌고, 많은 경우 데이터를 interpolate해서 regularly-sampled data (예컨대, 자연어 문장) 을 처리하는 모델을 통해 처리했습니다. t가 개입된 데이터를 효과적으로 다루는 방법은 2018년에 와서야 논문화 되었고 그 방법은 t를 모델 안에 내재시키는 방법입니다. (아주 간단히 말하면 기존 뉴럴넷의 레이어 뎁스가 N 같은 자연수였다면, 그 뎁스를 시간으로 사용하는 방법입니다; 그것도 연속적으로요)</p>

<p>현재 SoTA 모델들은 전부 이런 모델 = Neural ODEs (더 넓게는, Deep Implicit Layers)의 구조를 취하고 있으며 Vector Institute에서 이와 관련한 연구를 활발히 수행하고 있습니다. 대표적으로는 다음 논문들이 있습니다. <a href="https://arxiv.org/abs/1806.07366">Neural Ordinary Differential Equations</a>, <a href="https://arxiv.org/abs/2002.08071">Dissecting Neural ODEs</a>, <a href="https://arxiv.org/abs/1907.03907">Latent ODEs for Irregularly-Sampled Time Series</a>. Neural ODE를 사용한 인코더인 ODE-RNN의 코드는 <a href="https://github.com/YuliaRubanova/latent_ode">이 레포</a>를 참조해보세요.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>해당 섹션의 permutation invariance 관련 내용을 좀 더 상세하게 수정하였습니다. (2021-01-23) <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>이 아래로 inductive bias를 잘못 서술한 점이 있어서 지금 올바르다고 생각하는 방향으로 다시 서술하였습니다. permutation (in)variance에 관한 내용은 전개에 있어서 불필요하다 판단되어서 삭제하였습니다. (2021-02-08) <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </article>

  
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname  = 'dandelin';
      var disqus_identifier = '/blog/2021/Exploiting_Contemporary_ML';
      var disqus_title      = "Exploiting Contemporary ML";
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2026 Wonjae (Dan) Kim.
    
    
  </div>
</footer>



</body>

<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>

<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>


</html>